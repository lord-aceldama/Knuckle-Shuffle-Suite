###THE THEORY:
The Abacus class is designed to break a large keyspace into smaller chunks. When you 
consider the traditional incremental brute-force algoritm, it's clear  to see that 
keys starting with larger characters render incremental searches inefficient.


###FOR EXAMPLE:
Consider the keyspace [0-9a-f] when the 4-character key is "dacb" Abacus will scan 
permutations in keyspace as [0123------------], [1234, 2345, 3456, 4567, 5678, 6789, 
789a, 89ab, 9abc] and [----------abcd--] which means that the key will be discovered 
in under 2'176 keys. (11\*4^4 - 10\*4^3) In fact, having run the command *grep -n "dacb"*
and piping abacus's output into it, the token was found on line 1897. If the traditional
incremental search was used however, 56'011 of 65'536 keys would need to be tested before 
reaching the correct key.


###PITFALLS:
Of course this method is not fool-proof. If we consider the keyspace we used in the
example and "fed0" was the key, the entire keyspace would need to be scanned (as if 
"ffff" were the key used in an incremental search). When you take a normal (random)
distribution like a key generated by router manufacturers, _\*cough\* for educational 
purposes only \*cough\*_ it can be seen by looking at the curve on a graph that having
both the 1st and last chars  in the keyspace is highly unlikely. The following  curve
was generated by calculating the distance between the max and min characters of a 
random 5 character hex key over 10'000'000 iterations (ie. dacfb: f - a = 5 etc.):
        
                             Montecarlo Generated Graph:

            0.24|                      *  *
            0.22|                      *  *
            0.20|                   *  *  *  *
            0.18|                   *  *  *  *
            0.16|                   *  *  *  *
            0.14|                   *  *  *  *
            0.13|                   *  *  *  *
            0.12|                *  *  *  *  *  *
            0.10|                *  *  *  *  *  *
            0.08|                *  *  *  *  *  *
            0.06|                *  *  *  *  *  *
            0.04|             *  *  *  *  *  *  *  *
            0.02|       *  *  *  *  *  *  *  *  *  *  *  *
            0.00+-*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*-
                  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f

That being said,  there's always a chance that the full  65'536  keys may need to be
checked when brute-forcing a 4-digit hex key.
